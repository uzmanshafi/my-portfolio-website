---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - package.json
  - prisma/schema.prisma
  - prisma.config.ts
  - src/lib/prisma.ts
  - src/generated/prisma/
  - prisma/migrations/
  - tsconfig.json
autonomous: true

must_haves:
  truths:
    - "Prisma client generates without errors"
    - "Database migrations apply successfully"
    - "Prisma singleton connects to PostgreSQL with pooling"
    - "All content models exist in database"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Database schema with all content models"
      contains: "model Bio"
    - path: "prisma.config.ts"
      provides: "Prisma 7 configuration"
      contains: "defineConfig"
    - path: "src/lib/prisma.ts"
      provides: "Prisma client singleton with adapter"
      exports: ["prisma"]
    - path: "src/generated/prisma/client.ts"
      provides: "Generated Prisma client"
      contains: "PrismaClient"
  key_links:
    - from: "src/lib/prisma.ts"
      to: "src/generated/prisma/client"
      via: "import PrismaClient"
      pattern: "from.*generated/prisma"
    - from: "src/lib/prisma.ts"
      to: "@prisma/adapter-pg"
      via: "driver adapter"
      pattern: "PrismaPg"
    - from: "prisma.config.ts"
      to: ".env.local"
      via: "DATABASE_URL env var"
      pattern: "env\\('DATABASE_URL'\\)"
---

<objective>
Configure Prisma 7 ORM with PostgreSQL adapter and define all portfolio content models.

Purpose: Establish type-safe database access layer with proper connection pooling for the entire application.
Output: Generated Prisma client, applied migrations, and verified database connection with all content tables.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and Configure Prisma 7</name>
  <files>
    package.json
    prisma/schema.prisma
    prisma.config.ts
    tsconfig.json
  </files>
  <action>
1. Install Prisma 7 dependencies:
   ```bash
   npm install prisma @prisma/client @prisma/adapter-pg pg dotenv
   npm install -D @types/pg tsx
   ```

2. Initialize Prisma (creates prisma/ directory):
   ```bash
   npx prisma init --datasource-provider postgresql
   ```

3. Create prisma.config.ts (NEW in Prisma 7 - required):
   ```typescript
   import 'dotenv/config';
   import { defineConfig } from 'prisma/config';

   export default defineConfig({
     earlyAccess: true,
     schema: 'prisma/schema.prisma',
   });
   ```

4. Update prisma/schema.prisma with Prisma 7 configuration:
   ```prisma
   generator client {
     provider = "prisma-client"
     output   = "../src/generated/prisma"
   }

   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }
   ```

   IMPORTANT Prisma 7 changes:
   - Use `prisma-client` provider (NOT `prisma-client-js`)
   - Must specify explicit output path
   - DATABASE_URL stays in schema (prisma.config.ts is for other settings)

5. Update tsconfig.json to include prisma.config.ts:
   - Add "prisma.config.ts" to the "include" array

6. Add Prisma scripts to package.json:
   ```json
   "postinstall": "prisma generate",
   "db:generate": "prisma generate",
   "db:push": "prisma db push",
   "db:migrate": "prisma migrate dev",
   "db:migrate:deploy": "prisma migrate deploy",
   "db:studio": "prisma studio",
   "db:seed": "tsx prisma/seed.ts"
   ```
  </action>
  <verify>
Run `npx prisma generate` - should complete without errors (even with empty schema).
  </verify>
  <done>
Prisma 7 is installed and configured with correct provider, output path, and npm scripts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Prisma Singleton with Adapter</name>
  <files>
    src/lib/prisma.ts
  </files>
  <action>
Create src/lib/prisma.ts with the Prisma 7 singleton pattern:

```typescript
// src/lib/prisma.ts
// Prisma client singleton with pg adapter for Next.js
// Prevents connection exhaustion during hot reloading

import { PrismaClient } from '@/generated/prisma';
import { PrismaPg } from '@prisma/adapter-pg';
import pg from 'pg';

const { Pool } = pg;

// Extend globalThis to cache Prisma client and pool
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
  pool: pg.Pool | undefined;
};

// Create connection pool (reused across hot reloads)
const pool =
  globalForPrisma.pool ??
  new Pool({
    connectionString: process.env.DATABASE_URL,
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.pool = pool;
}

// Create adapter and client
const adapter = new PrismaPg(pool);

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    adapter,
    log:
      process.env.NODE_ENV === 'development'
        ? ['query', 'error', 'warn']
        : ['error'],
  });

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}
```

CRITICAL: This pattern:
1. Uses pg.Pool for connection pooling (prevents exhaustion)
2. Caches both Pool AND PrismaClient on globalThis
3. Only caches in development (production creates fresh instances)
4. Passes the adapter to PrismaClient (REQUIRED in Prisma 7)
  </action>
  <verify>
TypeScript compilation passes - run `npx tsc --noEmit` after Prisma client is generated.
  </verify>
  <done>
Prisma singleton with pg adapter and connection pooling is ready for use throughout the application.
  </done>
</task>

<task type="auto">
  <name>Task 3: Define Portfolio Data Models and Apply Migrations</name>
  <files>
    prisma/schema.prisma
    prisma/migrations/
    src/generated/prisma/
  </files>
  <action>
1. Update prisma/schema.prisma with complete portfolio models:

```prisma
generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Single bio/about content (one record)
model Bio {
  id          String   @id @default(cuid())
  name        String
  title       String   // "Software Developer"
  headline    String   // Short intro tagline
  description String   @db.Text // Full bio content
  imageUrl    String?  // Profile image URL
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Skills with categories and ordering
model Skill {
  id        String   @id @default(cuid())
  name      String
  icon      String   // Lucide icon name (e.g., "code", "database")
  category  String   // "frontend", "backend", "tools", "other"
  order     Int      @default(0)
  visible   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
  @@index([order])
}

// Projects with GitHub integration fields (for Phase 4)
model Project {
  id          String   @id @default(cuid())
  title       String
  description String   @db.Text
  imageUrl    String?  // Project screenshot/thumbnail
  liveUrl     String?  // Deployed project URL
  repoUrl     String?  // GitHub repository URL

  // GitHub sync fields (populated in Phase 4)
  githubId    Int?     @unique
  stars       Int      @default(0)
  forks       Int      @default(0)
  language    String?  // Primary language from GitHub

  // Display settings
  featured    Boolean  @default(false)
  visible     Boolean  @default(true)
  order       Int      @default(0)

  // Technologies used (stored as array)
  technologies String[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([featured, visible])
  @@index([order])
}

// Social media links
model SocialLink {
  id        String   @id @default(cuid())
  platform  String   // "github", "linkedin", "twitter", etc.
  url       String
  icon      String   // Lucide icon name
  order     Int      @default(0)
  visible   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([order])
}

// Resume/CV file tracking
model Resume {
  id        String   @id @default(cuid())
  filename  String   // Original filename
  url       String   // File URL (public/resume/ or cloud storage)
  active    Boolean  @default(true) // Only one active at a time
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Contact information
model Contact {
  id        String   @id @default(cuid())
  email     String
  location  String?  // Optional location display
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

2. Ensure PostgreSQL is running:
   ```bash
   npm run db:up
   ```

3. Generate Prisma client:
   ```bash
   npx prisma generate
   ```

4. Create initial migration:
   ```bash
   npx prisma migrate dev --name init
   ```
   This creates the migration file and applies it to the database.

5. Verify tables were created:
   ```bash
   npx prisma db pull --print
   ```
   Or use Prisma Studio:
   ```bash
   npx prisma studio
   ```
  </action>
  <verify>
Run these verification steps:
```bash
# 1. Generate client (should succeed)
npx prisma generate

# 2. Check migration was created
ls prisma/migrations/

# 3. Verify database has tables (use psql or Prisma Studio)
npx prisma studio
# OR
docker compose exec postgres psql -U postgres -d portfolio -c "\dt"
```
  </verify>
  <done>
All 6 content models (Bio, Skill, Project, SocialLink, Resume, Contact) exist in the database with proper indexes.
  </done>
</task>

</tasks>

<verification>
Run complete verification:

```bash
# 1. Prisma client generates without errors
npx prisma generate

# 2. TypeScript compiles (includes prisma imports)
npx tsc --noEmit

# 3. Database has all tables
docker compose exec postgres psql -U postgres -d portfolio -c "\dt"
# Expected: 6 tables + _prisma_migrations

# 4. Test connection in a simple script (optional)
# Create a quick test: npx tsx -e "import { prisma } from './src/lib/prisma'; prisma.bio.findMany().then(console.log).catch(console.error).finally(() => process.exit(0))"

# 5. Next.js still runs with Prisma
npm run dev
```
</verification>

<success_criteria>
- Prisma 7 installed with @prisma/adapter-pg and pg packages
- prisma.config.ts exists with correct configuration
- Prisma client generates to src/generated/prisma/
- Prisma singleton (src/lib/prisma.ts) uses pg.Pool adapter with caching
- All 6 models defined: Bio, Skill, Project, SocialLink, Resume, Contact
- Migration created and applied successfully
- Database contains all expected tables
- TypeScript compilation passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
