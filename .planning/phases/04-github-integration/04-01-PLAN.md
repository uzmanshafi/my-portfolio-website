---
phase: 04-github-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/github/client.ts
  - src/lib/github/types.ts
  - src/lib/github/encryption.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "npm run db:push completes with exit code 0"
    - "npx prisma studio displays GitHubConnection table with all columns"
    - "npx tsc --noEmit passes with no TypeScript errors"
    - "Encryption roundtrip test: encryptToken('test').then(decryptToken) returns 'test'"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "GitHubConnection model and Project sync fields"
      contains: "model GitHubConnection"
    - path: "src/lib/github/client.ts"
      provides: "Octokit client factory with throttling"
      exports: ["createGitHubClient"]
    - path: "src/lib/github/types.ts"
      provides: "TypeScript types for GitHub API responses"
      exports: ["GitHubRepo", "GitHubUser"]
    - path: "src/lib/github/encryption.ts"
      provides: "Token encryption/decryption using jose"
      exports: ["encryptToken", "decryptToken"]
  key_links:
    - from: "src/lib/github/client.ts"
      to: "octokit"
      via: "import"
      pattern: "import.*Octokit.*from.*octokit"
---

<objective>
Set up GitHub integration infrastructure: database schema, Octokit client, and token encryption.

Purpose: Foundation for all GitHub features - OAuth storage, API access, and sync tracking.
Output: Schema with GitHubConnection model, Octokit client factory, TypeScript types, token encryption utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-github-integration/04-RESEARCH.md

# Existing files to reference
@prisma/schema.prisma
@src/lib/auth.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install octokit and extend Prisma schema</name>
  <files>package.json, prisma/schema.prisma</files>
  <action>
1. Install octokit package:
   ```bash
   npm install octokit
   ```

2. Add GitHubConnection model to schema.prisma:
   ```prisma
   model GitHubConnection {
     id              String    @id @default(cuid())
     accessToken     String    // Encrypted with jose
     username        String
     avatarUrl       String?
     connectedAt     DateTime  @default(now())
     lastSyncAt      DateTime?
     syncError       String?   // Last sync error if any
   }
   ```

3. Add GitHub sync tracking fields to existing Project model.
   NOTE: The Project model already has these fields from Phase 3 schema:
   - githubId Int? @unique (ALREADY EXISTS - do not add)
   - stars Int @default(0) (ALREADY EXISTS - do not add)
   - forks Int @default(0) (ALREADY EXISTS - do not add)
   - language String? (ALREADY EXISTS - do not add)

   Add ONLY these NEW fields to the existing Project model:
   ```prisma
   // Add these new fields to existing Project model:
   githubFullName   String?   // owner/repo for API calls
   isGitHubSynced   Boolean   @default(false)
   customizedFields String[]  @default([])
   lastSyncedAt     DateTime?
   ```

4. Run `npm run db:push` to sync schema to database.
  </action>
  <verify>
- `npm run db:push` completes without errors (exit code 0)
- `npx prisma studio` shows GitHubConnection table
- Project table has new columns visible in Prisma Studio (githubFullName, isGitHubSynced, customizedFields, lastSyncedAt)
  </verify>
  <done>GitHubConnection model exists, Project model has githubFullName, isGitHubSynced, customizedFields, lastSyncedAt fields added (githubId, stars, forks, language already existed from Phase 3)</done>
</task>

<task type="auto">
  <name>Task 2: Create GitHub client factory and types</name>
  <files>src/lib/github/client.ts, src/lib/github/types.ts</files>
  <action>
1. Create `src/lib/github/types.ts` with TypeScript types:
   ```typescript
   // Types for GitHub API responses (subset of full API types)

   export interface GitHubUser {
     login: string;
     id: number;
     avatar_url: string;
     html_url: string;
     name: string | null;
   }

   export interface GitHubRepo {
     id: number;
     name: string;
     full_name: string;  // owner/repo
     description: string | null;
     html_url: string;
     stargazers_count: number;
     forks_count: number;
     language: string | null;
     private: boolean;
     updated_at: string;
     topics: string[];
   }

   // Simplified repo for UI display
   export interface RepoListItem {
     id: number;
     name: string;
     fullName: string;
     description: string | null;
     url: string;
     stars: number;
     forks: number;
     language: string | null;
     isPrivate: boolean;
     updatedAt: string;
     topics: string[];
   }

   // Transform GitHub API response to simplified type
   export function toRepoListItem(repo: GitHubRepo): RepoListItem {
     return {
       id: repo.id,
       name: repo.name,
       fullName: repo.full_name,
       description: repo.description,
       url: repo.html_url,
       stars: repo.stargazers_count,
       forks: repo.forks_count,
       language: repo.language,
       isPrivate: repo.private,
       updatedAt: repo.updated_at,
       topics: repo.topics,
     };
   }
   ```

2. Create `src/lib/github/client.ts` with Octokit factory:
   ```typescript
   import { Octokit } from 'octokit';

   /**
    * Creates an authenticated Octokit client with throttling.
    * Use this for all GitHub API interactions.
    */
   export function createGitHubClient(accessToken: string): Octokit {
     return new Octokit({
       auth: accessToken,
       throttle: {
         onRateLimit: (retryAfter, options, octokit, retryCount) => {
           octokit.log.warn(`Rate limit hit, retrying after ${retryAfter}s`);
           // Retry twice on rate limit
           return retryCount < 2;
         },
         onSecondaryRateLimit: (retryAfter, options, octokit) => {
           octokit.log.warn('Secondary rate limit hit, not retrying');
           return false;
         },
       },
     });
   }
   ```
  </action>
  <verify>
- TypeScript compiles without errors: `npx tsc --noEmit`
- Files exist at src/lib/github/client.ts and src/lib/github/types.ts
  </verify>
  <done>createGitHubClient factory exported, GitHubRepo and RepoListItem types defined with transformer</done>
</task>

<task type="auto">
  <name>Task 3: Create token encryption utilities</name>
  <files>src/lib/github/encryption.ts</files>
  <action>
1. Create `src/lib/github/encryption.ts` using jose library (already installed):
   ```typescript
   import { EncryptJWT, jwtDecrypt } from 'jose';

   // Secret key for encrypting GitHub tokens at rest
   // Uses AUTH_SECRET which is already required for Auth.js
   function getEncryptionKey(): Uint8Array {
     const secret = process.env.AUTH_SECRET;
     if (!secret) {
       throw new Error('AUTH_SECRET environment variable is required');
     }
     // Use first 32 chars of AUTH_SECRET as encryption key
     // jose requires a Uint8Array key
     return new TextEncoder().encode(secret.slice(0, 32).padEnd(32, '0'));
   }

   /**
    * Encrypts a GitHub access token for database storage.
    * Uses AES-256-GCM via jose's EncryptJWT.
    */
   export async function encryptToken(token: string): Promise<string> {
     const secret = getEncryptionKey();

     const jwt = await new EncryptJWT({ token })
       .setProtectedHeader({ alg: 'dir', enc: 'A256GCM' })
       .setIssuedAt()
       .encrypt(secret);

     return jwt;
   }

   /**
    * Decrypts a stored GitHub access token.
    */
   export async function decryptToken(encryptedToken: string): Promise<string> {
     const secret = getEncryptionKey();

     const { payload } = await jwtDecrypt(encryptedToken, secret);

     if (typeof payload.token !== 'string') {
       throw new Error('Invalid encrypted token payload');
     }

     return payload.token;
   }
   ```

2. Create barrel export at `src/lib/github/index.ts`:
   ```typescript
   export { createGitHubClient } from './client';
   export { encryptToken, decryptToken } from './encryption';
   export * from './types';
   ```
  </action>
  <verify>
- TypeScript compiles: `npx tsc --noEmit`
- Encryption/decryption can be tested manually if needed (will be used in OAuth flow)
  </verify>
  <done>encryptToken and decryptToken functions exported, GitHub module has clean barrel export</done>
</task>

</tasks>

<verification>
1. `npm run db:push` succeeded - schema is in sync
2. `npx tsc --noEmit` passes - no TypeScript errors
3. `npx prisma studio` shows GitHubConnection table and Project has new fields
4. Files exist:
   - src/lib/github/client.ts
   - src/lib/github/types.ts
   - src/lib/github/encryption.ts
   - src/lib/github/index.ts
</verification>

<success_criteria>
- GitHubConnection model in database with accessToken, username, avatarUrl, connectedAt, lastSyncAt, syncError fields
- Project model extended with githubFullName, isGitHubSynced, customizedFields, lastSyncedAt (githubId, stars, forks, language already exist from Phase 3)
- createGitHubClient() factory creates authenticated Octokit instance with throttling
- encryptToken/decryptToken utilities use jose for AES-256-GCM encryption
- All GitHub utilities importable from @/lib/github
</success_criteria>

<output>
After completion, create `.planning/phases/04-github-integration/04-01-SUMMARY.md`
</output>
