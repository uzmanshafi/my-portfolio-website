---
phase: 04-github-integration
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - src/lib/actions/github.ts
  - src/app/backstage/dashboard/github/repos-browser.tsx
  - src/components/admin/sortable-project-item.tsx
  - src/components/admin/project-form-modal.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can select GitHub repos and import them as portfolio projects"
    - "Imported projects show GitHub badge distinguishing them from manual projects"
    - "GitHub-synced projects pull name, description, stars, and primary language automatically"
    - "Admin can edit any field on a GitHub-synced project"
    - "Edited fields are tracked in customizedFields array to prevent sync overwrites"
  artifacts:
    - path: "src/lib/actions/github.ts"
      provides: "Import repos as projects action"
      exports: ["importRepositoriesAsProjects"]
    - path: "src/components/admin/sortable-project-item.tsx"
      provides: "GitHub badge on synced projects"
      contains: "isGitHubSynced"
  key_links:
    - from: "src/app/backstage/dashboard/github/repos-browser.tsx"
      to: "src/lib/actions/github.ts"
      via: "calls importRepositoriesAsProjects"
      pattern: "importRepositoriesAsProjects"
    - from: "src/lib/actions/github.ts"
      to: "prisma.project.create"
      via: "creates project from repo data"
      pattern: "prisma\\.project\\.create"
---

<objective>
Implement GitHub repo import as portfolio projects with sync tracking.

Purpose: Allow admin to add selected GitHub repos to portfolio with automatic metadata sync while preserving customization capability.
Output: Import action, GitHub badge on projects, customizedFields tracking for edited fields.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-github-integration/04-RESEARCH.md
@.planning/phases/04-github-integration/04-03-SUMMARY.md

# Existing files to reference
@src/lib/actions/github.ts
@src/lib/actions/projects.ts
@src/app/backstage/dashboard/github/repos-browser.tsx
@src/components/admin/sortable-project-item.tsx
@src/components/admin/project-form-modal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create import repos as projects server action</name>
  <files>src/lib/actions/github.ts</files>
  <action>
1. Add import action to `src/lib/actions/github.ts`:
   ```typescript
   import { revalidatePath } from "next/cache";
   import type { Project } from "@/generated/prisma/client";

   /**
    * Import selected GitHub repositories as portfolio projects.
    * Creates new Project records with GitHub sync enabled.
    */
   export async function importRepositoriesAsProjects(
     repos: RepoListItem[]
   ): Promise<ActionResult<Project[]>> {
     const session = await auth();
     if (!session?.user) {
       return failure("Unauthorized");
     }

     if (repos.length === 0) {
       return failure("No repositories selected");
     }

     try {
       // Get current max order for new projects
       const maxOrder = await prisma.project.aggregate({
         _max: { order: true },
       });
       let nextOrder = (maxOrder._max.order ?? -1) + 1;

       // Check which repos are already imported (by githubId)
       const existingGithubIds = await prisma.project.findMany({
         where: {
           githubId: { in: repos.map((r) => r.id) },
         },
         select: { githubId: true },
       });
       const existingIds = new Set(existingGithubIds.map((p) => p.githubId));

       // Filter out already imported repos
       const newRepos = repos.filter((r) => !existingIds.has(r.id));

       if (newRepos.length === 0) {
         return failure("All selected repositories are already imported");
       }

       // Create projects in a transaction
       const projects = await prisma.$transaction(
         newRepos.map((repo) => {
           const project = prisma.project.create({
             data: {
               title: repo.name,
               description: repo.description || `GitHub repository: ${repo.fullName}`,
               repoUrl: repo.url,
               githubId: repo.id,
               githubFullName: repo.fullName,
               stars: repo.stars,
               forks: repo.forks,
               language: repo.language,
               isGitHubSynced: true,
               customizedFields: [], // No customizations yet
               lastSyncedAt: new Date(),
               technologies: repo.language ? [repo.language] : [],
               visible: true,
               featured: false,
               order: nextOrder++,
             },
           });
           return project;
         })
       );

       revalidatePath("/backstage/dashboard/projects");
       revalidatePath("/backstage/dashboard/github");

       return success(projects);
     } catch (error) {
       console.error("Failed to import repositories:", error);
       return failure("Failed to import repositories");
     }
   }

   /**
    * Check which repos from a list are already imported.
    * Returns array of githubIds that exist as projects.
    */
   export async function getImportedRepoIds(
     githubIds: number[]
   ): Promise<ActionResult<number[]>> {
     const session = await auth();
     if (!session?.user) {
       return failure("Unauthorized");
     }

     try {
       const existing = await prisma.project.findMany({
         where: {
           githubId: { in: githubIds },
         },
         select: { githubId: true },
       });

       return success(existing.map((p) => p.githubId!).filter(Boolean));
     } catch (error) {
       console.error("Failed to check imported repos:", error);
       return failure("Failed to check imported repos");
     }
   }
   ```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- importRepositoriesAsProjects exported from actions file
  </verify>
  <done>importRepositoriesAsProjects creates Project records from selected repos with GitHub sync fields populated</done>
</task>

<task type="auto">
  <name>Task 2: Wire import action to repos browser UI</name>
  <files>src/app/backstage/dashboard/github/repos-browser.tsx</files>
  <action>
1. Update `src/app/backstage/dashboard/github/repos-browser.tsx`:

   Add import for the new action:
   ```typescript
   import { getRepositories, getLanguages, importRepositoriesAsProjects, getImportedRepoIds } from "@/lib/actions/github";
   ```

   Add state for tracking imported repos:
   ```typescript
   const [importedIds, setImportedIds] = useState<Set<number>>(new Set());
   const [isImporting, setIsImporting] = useState(false);
   ```

   Update fetchRepos to also check which are already imported:
   ```typescript
   const fetchRepos = useCallback(async (page: number, append = false) => {
     // ... existing loading logic ...

     const result = await getRepositories({...});

     if (result.success && result.data) {
       // ... existing success handling ...

       // Check which repos are already imported
       const allRepoIds = append
         ? [...repos, ...result.data.repos].map((r) => r.id)
         : result.data.repos.map((r) => r.id);

       const importedResult = await getImportedRepoIds(allRepoIds);
       if (importedResult.success && importedResult.data) {
         setImportedIds(new Set(importedResult.data));
       }
     }
     // ... rest of function ...
   }, [searchQuery, selectedLanguage, repos]);
   ```

   Replace handleAddSelected placeholder:
   ```typescript
   const handleAddSelected = async () => {
     const selectedItems = repos.filter((r) => selectedRepos.has(r.id));

     // Filter out already imported
     const newItems = selectedItems.filter((r) => !importedIds.has(r.id));

     if (newItems.length === 0) {
       toast.info("All selected repositories are already imported");
       return;
     }

     setIsImporting(true);
     const result = await importRepositoriesAsProjects(newItems);

     if (result.success) {
       toast.success(`Imported ${result.data?.length} project${result.data?.length === 1 ? "" : "s"}`);

       // Update imported IDs
       setImportedIds((prev) => {
         const next = new Set(prev);
         newItems.forEach((r) => next.add(r.id));
         return next;
       });

       // Clear selection
       setSelectedRepos(new Set());
     } else {
       toast.error(result.error || "Failed to import repositories");
     }

     setIsImporting(false);
   };
   ```

   Update RepoCard usage to show "Already added" state:
   ```typescript
   <RepoCard
     key={repo.id}
     repo={repo}
     selected={selectedRepos.has(repo.id)}
     onSelect={handleRepoSelect}
     disabled={importedIds.has(repo.id)}
     alreadyImported={importedIds.has(repo.id)}
   />
   ```

   Update button to show loading state:
   ```typescript
   <button
     onClick={handleAddSelected}
     disabled={isImporting}
     className="..."
   >
     {isImporting ? (
       <>
         <Loader2 size={18} className="animate-spin" />
         Importing...
       </>
     ) : (
       <>
         <Plus size={18} />
         Add to Portfolio
       </>
     )}
   </button>
   ```

2. Update `src/components/admin/repo-card.tsx` to show "Already added" badge:
   - Add `alreadyImported?: boolean` prop
   - Show "Already added" badge when true:
     ```typescript
     {alreadyImported && (
       <span
         className="absolute top-4 right-4 px-2 py-1 rounded text-xs font-medium"
         style={{
           backgroundColor: "rgba(34, 197, 94, 0.2)",
           color: "#22c55e",
         }}
       >
         Added
       </span>
     )}
     ```
   - Hide checkbox when alreadyImported is true
  </action>
  <verify>
- Select repos and click "Add to Portfolio"
- Toast shows "Imported X projects"
- Imported repos now show "Added" badge
- Imported repos cannot be selected
- Navigate to Projects page to see imported projects
  </verify>
  <done>Import action wired to UI, already-imported repos show "Added" badge and are disabled</done>
</task>

<task type="auto">
  <name>Task 3: Add GitHub badge to project items and track customizations</name>
  <files>src/components/admin/sortable-project-item.tsx, src/components/admin/project-form-modal.tsx, src/lib/actions/projects.ts</files>
  <action>
1. Update `src/components/admin/sortable-project-item.tsx`:
   - Add GitHub icon import from lucide-react
   - Show GitHub badge when project.isGitHubSynced is true:
     ```typescript
     {project.isGitHubSynced && (
       <span
         className="flex items-center gap-1 px-2 py-0.5 rounded text-xs font-medium"
         style={{
           backgroundColor: "rgba(211, 177, 150, 0.2)",
           color: "var(--color-primary)",
         }}
       >
         <Github size={12} />
         Synced
       </span>
     )}
     ```
   - Add badge near the title in the project item row

2. Update `src/components/admin/project-form-modal.tsx`:
   - Pass isGitHubSynced to track when editing a synced project
   - Show informational message when editing a GitHub-synced project:
     ```typescript
     {project?.isGitHubSynced && (
       <p
         className="text-sm mb-4 px-3 py-2 rounded-lg"
         style={{
           backgroundColor: "rgba(211, 177, 150, 0.1)",
           color: "var(--color-text)",
         }}
       >
         <strong>GitHub Synced:</strong> Changes you make here will be preserved during automatic sync.
       </p>
     )}
     ```

3. Update `src/lib/actions/projects.ts` - modify updateProject to track customizations:
   ```typescript
   export async function updateProject(
     id: string,
     formData: FormData
   ): Promise<ActionResult<Project>> {
     // ... existing validation ...

     try {
       const existing = await prisma.project.findUnique({ where: { id } });
       if (!existing) {
         return failure("Project not found");
       }

       // Track which fields are being customized (for GitHub-synced projects)
       let customizedFields = existing.customizedFields || [];

       if (existing.isGitHubSynced) {
         // Check which fields are different from original GitHub data
         const fieldsToCheck: (keyof typeof result.data)[] = [
           'title',
           'description',
         ];

         for (const field of fieldsToCheck) {
           const newValue = result.data[field];
           const existingValue = existing[field];

           if (newValue !== existingValue && !customizedFields.includes(field)) {
             customizedFields = [...customizedFields, field];
           }
         }
       }

       // Update project
       const project = await prisma.project.update({
         where: { id },
         data: {
           title: result.data.title,
           description: result.data.description,
           imageUrl: result.data.imageUrl || null,
           liveUrl: result.data.liveUrl || null,
           repoUrl: result.data.repoUrl || null,
           technologies: result.data.technologies,
           featured: result.data.featured,
           customizedFields,
         },
       });

       revalidatePath("/backstage/dashboard/projects");
       return success(project);
     } catch (error) {
       // ... error handling ...
     }
   }
   ```
  </action>
  <verify>
- Projects page shows GitHub badge on synced projects
- Edit modal shows info message for GitHub-synced projects
- Editing a synced project's title/description adds field to customizedFields
- Check database: customizedFields array contains edited field names
  </verify>
  <done>GitHub badge visible on synced projects, customizedFields tracks edited fields to protect from sync overwrites</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. From GitHub page:
   - Select 2-3 repos
   - Click "Add to Portfolio"
   - Toast shows success message
   - Repos now show "Added" badge
3. Navigate to Projects page:
   - Imported projects appear in list
   - GitHub badge ("Synced") visible on each
   - Stars, language, description populated from GitHub
4. Edit a GitHub-synced project:
   - Info message about sync appears
   - Change the title
   - Save
   - Check in Prisma Studio: customizedFields contains ["title"]
</verification>

<success_criteria>
- importRepositoriesAsProjects creates Project records with isGitHubSynced=true
- Repos browser shows "Added" badge and disables selection for imported repos
- Import shows loading state and success/error toasts
- Projects list shows GitHub badge on synced projects
- Editing a synced project tracks changed fields in customizedFields array
- customizedFields will be used in background sync (04-05) to skip those fields
</success_criteria>

<output>
After completion, create `.planning/phases/04-github-integration/04-04-SUMMARY.md`
</output>
