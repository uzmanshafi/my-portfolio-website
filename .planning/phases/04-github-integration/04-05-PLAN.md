---
phase: 04-github-integration
plan: 05
type: execute
wave: 5
depends_on: ["04-04"]
files_modified:
  - src/app/api/cron/sync-github/route.ts
  - src/lib/actions/github.ts
  - src/components/admin/project-form-modal.tsx
  - vercel.json
autonomous: true
user_setup:
  - service: vercel-cron
    why: "Cron endpoint needs authentication secret"
    env_vars:
      - name: CRON_SECRET
        source: "Generate with: openssl rand -base64 32"
    dashboard_config:
      - task: "Cron runs automatically on Vercel deploy; for local testing use curl with Authorization header"
        location: "N/A - automatic"

must_haves:
  truths:
    - "Background sync updates stars/forks/description for GitHub-synced projects"
    - "Background sync respects customizedFields - never overwrites admin edits"
    - "Projects from deleted/private repos are marked as hidden"
    - "Admin can reset individual fields to GitHub values"
    - "Cron endpoint is protected by CRON_SECRET"
  artifacts:
    - path: "src/app/api/cron/sync-github/route.ts"
      provides: "Vercel Cron endpoint for background sync"
      exports: ["GET"]
    - path: "vercel.json"
      provides: "Cron schedule configuration"
      contains: "sync-github"
  key_links:
    - from: "src/app/api/cron/sync-github/route.ts"
      to: "src/lib/actions/github.ts"
      via: "calls sync function"
      pattern: "syncGitHubProjects"
    - from: "src/lib/actions/github.ts"
      to: "prisma.project.update"
      via: "updates project fields from GitHub"
      pattern: "prisma\\.project\\.update"
---

<objective>
Implement background sync with Vercel Cron Jobs and per-field reset functionality.

Purpose: Keep GitHub-synced projects up-to-date automatically while respecting admin customizations and handling deleted repos.
Output: Daily background sync via cron, respects customizedFields, handles missing repos, per-field reset option.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-github-integration/04-RESEARCH.md
@.planning/phases/04-github-integration/04-04-SUMMARY.md

# Existing files to reference
@src/lib/actions/github.ts
@src/lib/github/client.ts
@src/components/admin/project-form-modal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create background sync logic and server action</name>
  <files>src/lib/actions/github.ts</files>
  <action>
1. Add sync functions to `src/lib/actions/github.ts`:
   ```typescript
   /**
    * Sync all GitHub-synced projects with latest data from GitHub.
    * Respects customizedFields - skips fields the admin has edited.
    * Marks projects as hidden if source repo is deleted or made private.
    *
    * @internal - Called by cron job, not directly from UI
    */
   export async function syncGitHubProjects(): Promise<ActionResult<{
     synced: number;
     hidden: number;
     errors: string[];
   }>> {
     const accessToken = await getGitHubAccessToken();
     if (!accessToken) {
       return failure("GitHub not connected");
     }

     try {
       const octokit = createGitHubClient(accessToken);

       // Get all GitHub-synced projects
       const projects = await prisma.project.findMany({
         where: { isGitHubSynced: true },
       });

       if (projects.length === 0) {
         return success({ synced: 0, hidden: 0, errors: [] });
       }

       let synced = 0;
       let hidden = 0;
       const errors: string[] = [];

       for (const project of projects) {
         if (!project.githubFullName) {
           errors.push(`Project ${project.id} missing githubFullName`);
           continue;
         }

         const [owner, repo] = project.githubFullName.split('/');

         try {
           const { data: repoData } = await octokit.rest.repos.get({
             owner,
             repo,
           });

           // Build update data, respecting customizedFields
           const customized = new Set(project.customizedFields || []);
           const updateData: Record<string, unknown> = {
             lastSyncedAt: new Date(),
           };

           // Only update fields that haven't been customized
           if (!customized.has('title')) {
             updateData.title = repoData.name;
           }
           if (!customized.has('description')) {
             updateData.description = repoData.description || `GitHub repository: ${repoData.full_name}`;
           }

           // Always update stats (not customizable)
           updateData.stars = repoData.stargazers_count;
           updateData.forks = repoData.forks_count;
           updateData.language = repoData.language;

           // Unhide if it was hidden due to missing repo
           if (!project.visible && !customized.has('visible')) {
             updateData.visible = true;
           }

           await prisma.project.update({
             where: { id: project.id },
             data: updateData,
           });

           synced++;
         } catch (repoError: any) {
           // Handle 404 (deleted) or 403 (private/no access)
           if (repoError.status === 404 || repoError.status === 403) {
             // Hide the project but don't delete it
             await prisma.project.update({
               where: { id: project.id },
               data: {
                 visible: false,
                 lastSyncedAt: new Date(),
               },
             });
             hidden++;
           } else {
             errors.push(`Failed to sync ${project.githubFullName}: ${repoError.message}`);
           }
         }
       }

       // Update GitHubConnection with sync status
       await prisma.gitHubConnection.updateMany({
         data: {
           lastSyncAt: new Date(),
           syncError: errors.length > 0 ? errors.join('; ') : null,
         },
       });

       return success({ synced, hidden, errors });
     } catch (error) {
       console.error("Failed to sync GitHub projects:", error);

       // Record sync error
       await prisma.gitHubConnection.updateMany({
         data: {
           syncError: error instanceof Error ? error.message : "Unknown error",
         },
       });

       return failure("Failed to sync GitHub projects");
     }
   }

   /**
    * Reset a specific field on a GitHub-synced project to the GitHub value.
    * Removes the field from customizedFields array.
    */
   export async function resetProjectFieldToGitHub(
     projectId: string,
     field: 'title' | 'description'
   ): Promise<ActionResult<Project>> {
     const session = await auth();
     if (!session?.user) {
       return failure("Unauthorized");
     }

     const accessToken = await getGitHubAccessToken();
     if (!accessToken) {
       return failure("GitHub not connected");
     }

     try {
       const project = await prisma.project.findUnique({
         where: { id: projectId },
       });

       if (!project) {
         return failure("Project not found");
       }

       if (!project.isGitHubSynced || !project.githubFullName) {
         return failure("Project is not GitHub-synced");
       }

       // Fetch current GitHub data
       const octokit = createGitHubClient(accessToken);
       const [owner, repo] = project.githubFullName.split('/');

       const { data: repoData } = await octokit.rest.repos.get({
         owner,
         repo,
       });

       // Get the GitHub value for the field
       let githubValue: string;
       switch (field) {
         case 'title':
           githubValue = repoData.name;
           break;
         case 'description':
           githubValue = repoData.description || `GitHub repository: ${repoData.full_name}`;
           break;
         default:
           return failure(`Cannot reset field: ${field}`);
       }

       // Remove field from customizedFields
       const customizedFields = (project.customizedFields || []).filter(
         (f) => f !== field
       );

       // Update project
       const updated = await prisma.project.update({
         where: { id: projectId },
         data: {
           [field]: githubValue,
           customizedFields,
         },
       });

       revalidatePath("/backstage/dashboard/projects");

       return success(updated);
     } catch (error) {
       console.error("Failed to reset field:", error);
       return failure("Failed to reset field to GitHub value");
     }
   }
   ```
  </action>
  <verify>
- `npx tsc --noEmit` passes
- syncGitHubProjects and resetProjectFieldToGitHub exported
  </verify>
  <done>syncGitHubProjects respects customizedFields, hides missing repos; resetProjectFieldToGitHub restores GitHub values</done>
</task>

<task type="auto">
  <name>Task 2: Create Vercel Cron endpoint</name>
  <files>src/app/api/cron/sync-github/route.ts, vercel.json</files>
  <action>
1. Create `src/app/api/cron/sync-github/route.ts`:
   ```typescript
   // Vercel Cron endpoint for background GitHub sync
   // Runs daily at 4 AM UTC to refresh GitHub project data
   // Protected by CRON_SECRET to prevent unauthorized access

   import { syncGitHubProjects } from "@/lib/actions/github";

   export const runtime = 'nodejs';
   export const dynamic = 'force-dynamic';

   export async function GET(request: Request) {
     // Verify request is from Vercel Cron (or authorized caller)
     const authHeader = request.headers.get('authorization');
     const cronSecret = process.env.CRON_SECRET;

     if (!cronSecret) {
       console.error("CRON_SECRET not configured");
       return new Response("Server configuration error", { status: 500 });
     }

     if (authHeader !== `Bearer ${cronSecret}`) {
       console.warn("Unauthorized cron request");
       return new Response("Unauthorized", { status: 401 });
     }

     console.log("Starting GitHub sync cron job...");

     const result = await syncGitHubProjects();

     if (result.success && result.data) {
       const { synced, hidden, errors } = result.data;

       console.log(`GitHub sync complete: ${synced} synced, ${hidden} hidden`);

       if (errors.length > 0) {
         console.warn("Sync errors:", errors);
       }

       return Response.json({
         success: true,
         synced,
         hidden,
         errors: errors.length > 0 ? errors : undefined,
       });
     } else {
       console.error("GitHub sync failed:", result.error);

       return Response.json(
         { success: false, error: result.error },
         { status: 500 }
       );
     }
   }
   ```

2. Create or update `vercel.json` in project root:
   ```json
   {
     "crons": [
       {
         "path": "/api/cron/sync-github",
         "schedule": "0 4 * * *"
       }
     ]
   }
   ```

   Note: "0 4 * * *" means daily at 4:00 AM UTC.
  </action>
  <verify>
- File exists at src/app/api/cron/sync-github/route.ts
- vercel.json exists with cron configuration
- Test locally (add CRON_SECRET to .env.local):
  ```bash
  curl -H "Authorization: Bearer YOUR_CRON_SECRET" http://localhost:3000/api/cron/sync-github
  ```
  Should return JSON with synced/hidden counts
  </verify>
  <done>Cron endpoint created, protected by CRON_SECRET, vercel.json configured for daily 4 AM sync</done>
</task>

<task type="auto">
  <name>Task 3: Add per-field reset UI to project form</name>
  <files>src/components/admin/project-form-modal.tsx</files>
  <action>
1. Update `src/components/admin/project-form-modal.tsx`:
   - Import resetProjectFieldToGitHub action
   - Import RotateCcw icon from lucide-react
   - Add reset button state

   For GitHub-synced projects with customized fields, show reset button next to those fields:
   ```typescript
   // Add state for resetting
   const [resettingField, setResettingField] = useState<string | null>(null);

   // Add reset handler
   const handleResetField = async (field: 'title' | 'description') => {
     if (!project?.id) return;

     setResettingField(field);

     const result = await resetProjectFieldToGitHub(project.id, field);

     if (result.success && result.data) {
       // Update form value
       if (field === 'title') {
         form.setValue('title', result.data.title);
       } else if (field === 'description') {
         form.setValue('description', result.data.description);
       }
       toast.success(`${field} reset to GitHub value`);
     } else {
       toast.error(result.error || `Failed to reset ${field}`);
     }

     setResettingField(null);
   };
   ```

   For Title field, show reset button if customized:
   ```typescript
   <div className="space-y-2">
     <div className="flex items-center justify-between">
       <label ...>Title</label>
       {project?.isGitHubSynced && project?.customizedFields?.includes('title') && (
         <button
           type="button"
           onClick={() => handleResetField('title')}
           disabled={resettingField === 'title'}
           className="flex items-center gap-1 text-xs transition-colors"
           style={{ color: "var(--color-primary)" }}
         >
           {resettingField === 'title' ? (
             <Loader2 size={12} className="animate-spin" />
           ) : (
             <RotateCcw size={12} />
           )}
           Reset to GitHub
         </button>
       )}
     </div>
     <input ... />
   </div>
   ```

   Similar for Description field:
   ```typescript
   <div className="space-y-2">
     <div className="flex items-center justify-between">
       <label ...>Description</label>
       {project?.isGitHubSynced && project?.customizedFields?.includes('description') && (
         <button
           type="button"
           onClick={() => handleResetField('description')}
           disabled={resettingField === 'description'}
           className="flex items-center gap-1 text-xs transition-colors"
           style={{ color: "var(--color-primary)" }}
         >
           {resettingField === 'description' ? (
             <Loader2 size={12} className="animate-spin" />
           ) : (
             <RotateCcw size={12} />
           )}
           Reset to GitHub
         </button>
       )}
     </div>
     <textarea ... />
   </div>
   ```
  </action>
  <verify>
- Edit a GitHub-synced project
- Change the title, save
- Reopen edit modal
- "Reset to GitHub" button appears next to title
- Click reset - title reverts to GitHub value
- Button disappears after reset (field no longer in customizedFields)
  </verify>
  <done>Per-field "Reset to GitHub" buttons appear for customized fields on GitHub-synced projects</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Add CRON_SECRET to .env.local
3. Test cron endpoint:
   ```bash
   curl -H "Authorization: Bearer YOUR_SECRET" http://localhost:3000/api/cron/sync-github
   ```
   Returns { success: true, synced: N, hidden: M }
4. Edit a GitHub-synced project:
   - Change title, save
   - Check Prisma Studio: customizedFields contains ["title"]
5. Run sync again via curl:
   - Title should NOT be overwritten (it's in customizedFields)
   - Stars/forks should be updated
6. Open project edit modal:
   - "Reset to GitHub" shows next to Title
   - Click it - title reverts
   - customizedFields no longer contains "title"
7. vercel.json has cron configuration for daily sync
</verification>

<success_criteria>
- /api/cron/sync-github endpoint exists, protected by CRON_SECRET
- syncGitHubProjects updates stars/forks/language without overwriting customized title/description
- Projects with 404/403 repos are marked visible: false (hidden)
- vercel.json configures daily cron at 4 AM UTC
- Edit modal shows "Reset to GitHub" buttons for customized fields
- Resetting removes field from customizedFields and restores GitHub value
- GitHubConnection.lastSyncAt updated after each sync
- Sync errors stored in GitHubConnection.syncError
</success_criteria>

<output>
After completion, create `.planning/phases/04-github-integration/04-05-SUMMARY.md`
</output>
