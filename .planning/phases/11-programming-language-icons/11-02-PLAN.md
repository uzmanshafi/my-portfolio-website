---
phase: 11-programming-language-icons
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/components/ui/tech-icon.tsx
  - src/lib/icons/icon-matcher.ts
  - src/hooks/use-recent-icons.ts
autonomous: true

must_haves:
  truths:
    - "TechIcon component renders devicon when iconType='devicon' or Lucide fallback when iconType='lucide'"
    - "Icon matcher finds matching devicon for skill names like 'React', 'ReactJS', 'react.js'"
    - "Recent icons hook persists last 8 selected icons in localStorage"
    - "TechIcon uses currentColor for monochrome design system integration"
  artifacts:
    - path: "src/components/ui/tech-icon.tsx"
      provides: "Unified icon component for both admin and public portfolio"
      exports: ["TechIcon"]
    - path: "src/lib/icons/icon-matcher.ts"
      provides: "Fuzzy matching logic for auto-suggesting icons"
      exports: ["findMatchingIcon"]
    - path: "src/hooks/use-recent-icons.ts"
      provides: "localStorage persistence hook for recent icons"
      exports: ["useRecentIcons"]
  key_links:
    - from: "src/components/ui/tech-icon.tsx"
      to: "src/lib/icons/devicon-registry.ts"
      via: "DEVICON_MAP lookup"
      pattern: "DEVICON_MAP\\.get"
    - from: "src/lib/icons/icon-matcher.ts"
      to: "src/lib/icons/devicon-registry.ts"
      via: "DEVICON_REGISTRY search"
      pattern: "DEVICON_REGISTRY\\.find"
---

<objective>
Create TechIcon component for unified icon rendering, icon matcher for auto-suggestion, and localStorage hook for recent icons.

Purpose: These utilities are required by the icon picker modal (Plan 03) and the skill form integration (Plan 04).
Output: Reusable TechIcon component, findMatchingIcon helper, useRecentIcons hook.
</objective>

<execution_context>
@/Users/uzi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/uzi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-programming-language-icons/11-CONTEXT.md
@.planning/phases/11-programming-language-icons/11-RESEARCH.md
@.planning/phases/11-programming-language-icons/11-01-SUMMARY.md
@src/lib/icons/devicon-registry.ts
@src/lib/icons/icon-categories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TechIcon component</name>
  <files>src/components/ui/tech-icon.tsx</files>
  <action>
    Create src/components/ui/tech-icon.tsx - unified component rendering devicon or Lucide based on iconType:

    ```typescript
    "use client";

    import { DEVICON_MAP } from "@/lib/icons/devicon-registry";
    import { CATEGORY_FALLBACKS } from "@/lib/icons/icon-categories";
    import type { SkillCategory } from "@/lib/validations/skill";
    import * as LucideIcons from "lucide-react";
    import type { LucideIcon } from "lucide-react";

    interface TechIconProps {
      iconType: "devicon" | "lucide";
      iconId: string;
      skillCategory?: SkillCategory;  // For fallback selection
      size?: number;
      className?: string;
    }

    /**
     * Helper to render dynamic Lucide icon from string name.
     * Converts kebab-case to PascalCase for Lucide lookup.
     */
    function getLucideIcon(name: string): LucideIcon {
      const pascalCase = name
        .split("-")
        .map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
        .join("");

      const icons = LucideIcons as unknown as Record<string, LucideIcon>;
      return icons[pascalCase] || LucideIcons.Code;
    }

    /**
     * Unified icon component that renders either a devicon (tech logo)
     * or a Lucide icon, with category-based fallback.
     *
     * Used in both admin skill editor and public portfolio for consistency.
     */
    export function TechIcon({
      iconType,
      iconId,
      skillCategory = "other",
      size = 20,
      className,
    }: TechIconProps) {
      // Try devicon first if iconType is "devicon"
      if (iconType === "devicon") {
        const devicon = DEVICON_MAP.get(iconId);

        if (devicon) {
          const IconComponent = devicon.component;
          return (
            <IconComponent
              color="currentColor"
              style={{ width: size, height: size }}
              className={className}
            />
          );
        }

        // Devicon not found - fall back to category Lucide icon
        const FallbackIcon = CATEGORY_FALLBACKS[skillCategory];
        return <FallbackIcon size={size} className={className} />;
      }

      // iconType is "lucide" - render Lucide icon
      const LucideIconComponent = getLucideIcon(iconId);
      return <LucideIconComponent size={size} className={className} />;
    }
    ```

    Key implementation details:
    - "use client" directive for React components
    - Accepts iconType to determine which icon system to use
    - For devicons: Uses DEVICON_MAP for O(1) lookup, renders with color="currentColor"
    - For Lucide: Uses dynamic import pattern matching existing skill-card.tsx
    - Falls back to category-based Lucide icon if devicon not found
    - size prop controls both width/height consistently
    - className passed through for additional styling
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - Component exports TechIcon function
    - Import in a test file and render with both iconType values
  </verify>
  <done>
    - TechIcon component renders devicons with color="currentColor"
    - TechIcon component renders Lucide icons for iconType="lucide"
    - Graceful fallback to category Lucide icon if devicon not found
  </done>
</task>

<task type="auto">
  <name>Task 2: Create icon matcher and recent icons hook</name>
  <files>src/lib/icons/icon-matcher.ts, src/hooks/use-recent-icons.ts</files>
  <action>
    1. Create src/lib/icons/icon-matcher.ts - fuzzy matching for auto-suggest:

    ```typescript
    import { DEVICON_REGISTRY, type DeviconEntry } from "./devicon-registry";

    /**
     * Find best matching devicon for a skill name.
     * Uses cascading match strategy: exact name -> exact alias -> partial match.
     * Returns null if no good match found.
     *
     * @example
     * findMatchingIcon("React") // returns React entry
     * findMatchingIcon("ReactJS") // returns React entry (via alias)
     * findMatchingIcon("react.js") // returns React entry (via alias)
     * findMatchingIcon("Unknown Skill") // returns null
     */
    export function findMatchingIcon(skillName: string): DeviconEntry | null {
      const normalized = skillName.toLowerCase().trim();

      // 1. Exact match on name or id
      const exactMatch = DEVICON_REGISTRY.find(
        (icon) =>
          icon.name.toLowerCase() === normalized || icon.id === normalized
      );
      if (exactMatch) return exactMatch;

      // 2. Exact alias match
      const aliasMatch = DEVICON_REGISTRY.find((icon) =>
        icon.aliases.some((alias) => alias === normalized)
      );
      if (aliasMatch) return aliasMatch;

      // 3. Partial match - name/alias contains search or search contains name/alias
      const partialMatch = DEVICON_REGISTRY.find(
        (icon) =>
          icon.name.toLowerCase().includes(normalized) ||
          normalized.includes(icon.name.toLowerCase()) ||
          icon.aliases.some(
            (alias) =>
              alias.includes(normalized) || normalized.includes(alias)
          )
      );
      if (partialMatch) return partialMatch;

      return null;
    }

    /**
     * Search devicons by query string.
     * Returns icons matching name, id, or aliases (case-insensitive).
     * Used by icon picker search.
     */
    export function searchDevicons(query: string): DeviconEntry[] {
      if (!query.trim()) return DEVICON_REGISTRY;

      const normalized = query.toLowerCase().trim();

      return DEVICON_REGISTRY.filter(
        (icon) =>
          icon.name.toLowerCase().includes(normalized) ||
          icon.id.includes(normalized) ||
          icon.aliases.some((alias) => alias.includes(normalized))
      );
    }
    ```

    2. Create src/hooks/use-recent-icons.ts - localStorage persistence:

    ```typescript
    "use client";

    import { useState, useEffect, useCallback } from "react";

    const STORAGE_KEY = "portfolio-recent-icons";
    const MAX_RECENT = 8;

    /**
     * Hook for managing recently used icons in localStorage.
     * Initializes empty on server, hydrates from localStorage on client.
     * This prevents SSR hydration mismatch.
     *
     * @returns { recentIcons: string[], addRecentIcon: (iconId: string) => void }
     */
    export function useRecentIcons() {
      const [recentIcons, setRecentIcons] = useState<string[]>([]);

      // Load from localStorage on mount (client-side only)
      useEffect(() => {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
            const parsed = JSON.parse(stored);
            if (Array.isArray(parsed)) {
              setRecentIcons(parsed);
            }
          }
        } catch {
          // Ignore localStorage errors (private browsing, full storage, etc.)
        }
      }, []);

      const addRecentIcon = useCallback((iconId: string) => {
        setRecentIcons((current) => {
          // Remove if already exists, add to front, limit size
          const filtered = current.filter((id) => id !== iconId);
          const updated = [iconId, ...filtered].slice(0, MAX_RECENT);

          // Persist to localStorage
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
          } catch {
            // Ignore localStorage errors
          }

          return updated;
        });
      }, []);

      return { recentIcons, addRecentIcon };
    }
    ```

    Key implementation details:
    - icon-matcher uses cascading strategy: exact -> alias -> partial
    - searchDevicons returns all icons when query is empty (for initial picker display)
    - useRecentIcons initializes empty to avoid SSR hydration mismatch
    - localStorage operations wrapped in try/catch for private browsing mode
    - MAX_RECENT = 8 shows one row of recent icons in picker
  </action>
  <verify>
    - TypeScript compiles: `npx tsc --noEmit`
    - findMatchingIcon("React") returns React entry
    - findMatchingIcon("react.js") returns React entry (alias match)
    - searchDevicons("type") returns TypeScript and related icons
  </verify>
  <done>
    - findMatchingIcon does cascading exact/alias/partial matching
    - searchDevicons filters icons by name/id/aliases
    - useRecentIcons persists to localStorage without SSR hydration issues
    - MAX_RECENT = 8 icons stored
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes with no type errors
2. TechIcon renders devicons with currentColor
3. TechIcon renders Lucide icons when iconType="lucide"
4. findMatchingIcon("React") returns correct entry
5. findMatchingIcon("Unknown") returns null
6. useRecentIcons hook initializes empty array (no hydration error)
</verification>

<success_criteria>
- TechIcon component renders both devicons and Lucide icons based on iconType
- Devicons use color="currentColor" for monochrome design
- Icon matcher finds matches for common variations (React, ReactJS, react.js)
- Recent icons hook persists to localStorage without SSR issues
- All utilities are properly typed and exportable
</success_criteria>

<output>
After completion, create `.planning/phases/11-programming-language-icons/11-02-SUMMARY.md`
</output>
